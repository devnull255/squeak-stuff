Object subclass: #Cell	instanceVariableNames: 'activeSegments exitSides gridLocation'	classVariableNames: ''	poolDictionaries: ''	category: 'Laser-Game-Model'!!Cell methodsFor: 'accessing' stamp: 'mdm 1/28/2014 07:57'!activeSegments	^ activeSegments! !!Cell methodsFor: 'accessing' stamp: 'mdm 1/28/2014 07:57'!activeSegments: anObject	activeSegments := anObject! !!Cell methodsFor: 'accessing' stamp: 'mdm 1/30/2014 07:32'!exitSideFor: aSymbol	"returns exitSide for a symbol"	^self exitSides at: aSymbol! !!Cell methodsFor: 'accessing' stamp: 'mdm 1/28/2014 07:58'!exitSides	^ exitSides! !!Cell methodsFor: 'accessing' stamp: 'mdm 1/28/2014 07:59'!exitSides: anObject	exitSides := anObject! !!Cell methodsFor: 'accessing' stamp: 'mdm 2/24/2014 07:46'!gridLocation	^ gridLocation! !!Cell methodsFor: 'accessing' stamp: 'mdm 2/24/2014 07:46'!gridLocation: anObject	gridLocation := anObject! !!Cell methodsFor: 'accessing' stamp: 'mdm 1/30/2014 07:36'!laserEntersFrom: aSymbol	"activate line segments based on entry point from aSymbol"	| exit |	self activeSegments at: aSymbol put: true.	exit := self exitSideFor: aSymbol.	self activeSegments at: exit put: true.! !!Cell methodsFor: 'initialize-release' stamp: 'mdm 1/28/2014 08:03'!initialize	"Initialize activesegments"       super initialize.       self initializeActiveSegments.! !!Cell methodsFor: 'initialize-release' stamp: 'mdm 1/28/2014 08:01'!initializeActiveSegments	"initialize activeSegments dictionary"	self activeSegments: Dictionary new.	self activeSegments at: #north put: false.	self activeSegments at: #east put: false.	self activeSegments at: #west put: false.	self activeSegments at: #south put: false.	! !!Cell methodsFor: 'testing' stamp: 'mdm 1/30/2014 07:34'!isOff	"returns whether cell is off"      ^self isOn not.! !!Cell methodsFor: 'testing' stamp: 'mdm 1/30/2014 07:35'!isOn	"returns whether the cell is on"       ^self activeSegments values anySatisfy: [:each | each = true]! !!Cell methodsFor: 'testing' stamp: 'mdm 1/30/2014 07:36'!isSegmentOnFor: aSymbol	"is line segment on in the cell"	^self activeSegments at: aSymbol! !Cell subclass: #BlankCell	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Laser-Game-Model'!!BlankCell methodsFor: 'initialize-release' stamp: 'mdm 1/28/2014 08:02'!initialize	"Initialize object"	super initialize.	self initializeExitSides.! !!BlankCell methodsFor: 'initialize-release' stamp: 'mdm 1/26/2014 14:29'!initializeExitSides	"initialize where the laser beam will exit through"      self exitSides: Dictionary new.      self exitSides at: #north put: #south.      self exitSides at: #east put: #west.      self exitSides at: #south put: #north.      self exitSides at: #west put: #east.! !Object subclass: #Grid	instanceVariableNames: 'cells laserIsActive numberOfRows numberOfColumns laserBeamPath'	classVariableNames: ''	poolDictionaries: ''	category: 'Laser-Game-Model'!!Grid methodsFor: 'accessing' stamp: 'mdm 2/27/2014 07:54'!activateCellsInPath	"activate all cells in Laserbeam's path"      self calculatePath.      self laserBeamPath do: [:pe |	     pe activateCell]! !!Grid methodsFor: 'accessing' stamp: 'mdm 2/18/2014 21:53'!at: aPoint	"returns a cell"      self revisit: 'sbw 02/17/2014 - We should add a more meaningful accessing technique here. x@y is confusing.'.      ^self cells at: aPoint ifAbsent: []! !!Grid methodsFor: 'accessing' stamp: 'mdm 2/24/2014 07:47'!at: aPoint put: aCell	"Update a cell"	self revisit: 'sbw 02/14/2014 - We should add a more meaningful accessing technique here. x@y is confusing.'.	aCell gridLocation: aPoint.      self cells at: aPoint put: aCell! !!Grid methodsFor: 'accessing' stamp: 'mdm 2/27/2014 07:53'!calculatePath	"Calculates LaserBeamPath through grid"	| cell dirSym element next |	self laserBeamPath: OrderedCollection new.	cell := self startingCell.	dirSym := #south.	element := LaserPathElement cell: cell entrySide: dirSym.	[self laserBeamPath addLast: element.	next := element nextElementIn: self.	next isNil]  whileFalse: [	    element := next]! !!Grid methodsFor: 'accessing' stamp: 'mdm 2/5/2014 07:53'!cells	^ cells! !!Grid methodsFor: 'accessing' stamp: 'mdm 2/5/2014 07:53'!cells: anObject	cells := anObject! !!Grid methodsFor: 'accessing' stamp: 'mdm 2/24/2014 07:43'!laserBeamPath	^ laserBeamPath! !!Grid methodsFor: 'accessing' stamp: 'mdm 2/24/2014 07:43'!laserBeamPath: anObject	laserBeamPath := anObject! !!Grid methodsFor: 'accessing' stamp: 'mdm 2/5/2014 07:53'!laserIsActive	^ laserIsActive! !!Grid methodsFor: 'accessing' stamp: 'mdm 2/5/2014 07:53'!laserIsActive: anObject	laserIsActive := anObject! !!Grid methodsFor: 'accessing' stamp: 'mdm 2/5/2014 08:01'!numberOfColumns      numberOfColumns isNil ifTrue: [self numberOfColumns: 1].	^ numberOfColumns! !!Grid methodsFor: 'accessing' stamp: 'mdm 2/5/2014 07:54'!numberOfColumns: anObject	numberOfColumns := anObject! !!Grid methodsFor: 'accessing' stamp: 'mdm 2/5/2014 08:06'!numberOfRows      numberOfRows isNil ifTrue: [self numberOfRows: 1].	^ numberOfRows! !!Grid methodsFor: 'accessing' stamp: 'mdm 2/5/2014 07:54'!numberOfRows: anObject	numberOfRows := anObject! !!Grid methodsFor: 'accessing' stamp: 'mdm 2/24/2014 07:45'!startingCell	"returns starting cell"      | pt |      pt := 1@(self numberOfRows).      ^self at: pt! !!Grid methodsFor: 'initialize-release' stamp: 'mdm 2/5/2014 07:57'!initialize	"initialize this grid"      super initialize.      self laserIsActive: false.      self initializeCells.! !!Grid methodsFor: 'initialize-release' stamp: 'mdm 2/28/2014 06:35'!initializeCells	"Initialize the cells of the grid"      self cells: Dictionary new.      1 to: self numberOfColumns do: [:x |	    1 to: self numberOfRows do: [:y |		  | pt cell |		  pt := x@y.		  cell := BlankCell new.		  self at: pt put: cell]]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Grid class	instanceVariableNames: ''!!Grid class methodsFor: 'instance creation' stamp: 'mdm 2/13/2014 07:44'!newOfSize: aPoint	"initialize a new grid with a specified size"	| model |	model := self basicNew.	model 	        numberOfRows: aPoint y;	        numberOfColumns: aPoint x.	model initialize.	^model! !Object subclass: #GridDirection	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Laser-Game-Model'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GridDirection class	instanceVariableNames: ''!!GridDirection class methodsFor: 'as yet unclassified' stamp: 'mdm 3/5/2014 08:21'!directionFor: aSymbol	"returns direction from subclasses"      ^self subclasses detect: [:cls | cls directionSymbol = aSymbol].! !GridDirection subclass: #GridDirectionEast	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Laser-Game-Model'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GridDirectionEast class	instanceVariableNames: ''!!GridDirectionEast class methodsFor: 'as yet unclassified' stamp: 'mdm 3/5/2014 08:19'!adjacentInversionSymbol	"Returns symbol adjacent to this one"      ^#west! !!GridDirectionEast class methodsFor: 'as yet unclassified' stamp: 'mdm 2/26/2014 08:44'!directionSymbol	"comment stating purpose of message"      ^#east! !!GridDirectionEast class methodsFor: 'as yet unclassified' stamp: 'mdm 3/2/2014 11:03'!vector	"comment stating purpose of message"      ^(1@0)! !GridDirection subclass: #GridDirectionNorth	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Laser-Game-Model'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GridDirectionNorth class	instanceVariableNames: ''!!GridDirectionNorth class methodsFor: 'as yet unclassified' stamp: 'mdm 2/28/2014 07:39'!adjacentInversionSymbol	"returns inverted symbol for adjacent cell"      ^#south! !!GridDirectionNorth class methodsFor: 'as yet unclassified' stamp: 'mdm 2/27/2014 07:20'!directionSymbol	"returns symbol"      ^#north! !!GridDirectionNorth class methodsFor: 'as yet unclassified' stamp: 'mdm 3/2/2014 11:03'!vector	"returns vector for direction"       ^(0@ -1)! !GridDirection subclass: #GridDirectionSouth	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Laser-Game-Model'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GridDirectionSouth class	instanceVariableNames: ''!!GridDirectionSouth class methodsFor: 'as yet unclassified' stamp: 'mdm 2/28/2014 07:40'!adjacentInversionSymbol	"returns inverted symbol for adjacent cell"      ^#north! !!GridDirectionSouth class methodsFor: 'as yet unclassified' stamp: 'mdm 2/26/2014 08:48'!directionSymbol	"returns direction symbol south"       ^#south! !!GridDirectionSouth class methodsFor: 'as yet unclassified' stamp: 'mdm 3/2/2014 11:03'!vector	"returns the direction vector"      ^(0@1)! !GridDirection subclass: #GridDirectionWest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Laser-Game-Model'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GridDirectionWest class	instanceVariableNames: ''!!GridDirectionWest class methodsFor: 'as yet unclassified' stamp: 'mdm 3/5/2014 08:20'!adjacentInversionSymbol	"returns adjacent direction symbol"      ^#east! !!GridDirectionWest class methodsFor: 'as yet unclassified' stamp: 'mdm 2/26/2014 08:51'!directionSymbol	"returns west direction symbol"      ^#west! !!GridDirectionWest class methodsFor: 'as yet unclassified' stamp: 'mdm 3/2/2014 11:03'!vector	"returns vector for direction"      ^(-1@0)! !Object subclass: #GridFactory	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Laser-Game-Model'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GridFactory class	instanceVariableNames: ''!!GridFactory class methodsFor: 'as yet unclassified' stamp: 'mdm 3/6/2014 07:27'!demoGrid	"generates a demo grid"      | grid |      grid := Grid newOfSize: 5@5.      grid at: 4@1 put: MirrorCell leanRight.      grid at: 5@1 put: TargetCell new.      grid at: 1@2 put: MirrorCell leanRight.      grid at: 5@2 put: MirrorCell leanLeft.      grid at: 2@3 put: MirrorCell leanLeft.      grid at: 3@3 put: MirrorCell leanRight.      grid at: 5@3 put: MirrorCell leanLeft.      grid at: 2@4 put: MirrorCell leanLeft.      grid at: 3@4 put: MirrorCell leanLeft.      grid at: 1@5 put: MirrorCell leanRight.      grid at: 4@5 put: MirrorCell leanRight.      ^grid	! !Object subclass: #LaserPathElement	instanceVariableNames: 'cell entrySide'	classVariableNames: ''	poolDictionaries: ''	category: 'Laser-Game-Model'!!LaserPathElement methodsFor: 'accessing' stamp: 'mdm 2/24/2014 07:41'!cell	^ cell! !!LaserPathElement methodsFor: 'accessing' stamp: 'mdm 2/24/2014 07:41'!cell: anObject	cell := anObject! !!LaserPathElement methodsFor: 'accessing' stamp: 'mdm 2/24/2014 07:41'!entrySide	^ entrySide! !!LaserPathElement methodsFor: 'accessing' stamp: 'mdm 2/24/2014 07:41'!entrySide: anObject	entrySide := anObject! !!LaserPathElement methodsFor: 'as yet unclassified' stamp: 'mdm 3/2/2014 12:00'!activateCell	"activate cell signifying laserbeam as entered it"      self cell laserEntersFrom: self entrySide.      Transcript show: '['.      Transcript show: DateAndTime current.      Transcript show: ']'.      Transcript show: 'Now entering cell at '.      Transcript show: (cell gridLocation).       Transcript show: ' from the '.       Transcript show: (self entrySide);cr.! !!LaserPathElement methodsFor: 'as yet unclassified' stamp: 'mdm 2/28/2014 07:54'!nextElementIn: aGrid	"Returns the next element in the grid"	| loc dirSym direction vector newLoc nextCell |	loc := self cell gridLocation.	dirSym := self cell exitSideFor: self entrySide.	dirSym isNil ifTrue: [^nil].	direction := GridDirection directionFor: dirSym.	vector := direction vector.	newLoc := loc + vector.	nextCell := aGrid at: newLoc.	^nextCell isNil	       ifTrue: [nil]	       ifFalse: [self class cell: nextCell entrySide: direction adjacentInversionSymbol]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!LaserPathElement class	instanceVariableNames: ''!!LaserPathElement class methodsFor: 'as yet unclassified' stamp: 'mdm 2/28/2014 07:34'!cell: aCell entrySide: aSymbol	"Returns a LaserPathElement instance with cell and entry side"	| model |	model := self basicNew.	model	       cell: aCell;	       entrySide: aSymbol.	model initialize.	^model! !Cell subclass: #MirrorCell	instanceVariableNames: 'leansLeft'	classVariableNames: ''	poolDictionaries: ''	category: 'Laser-Game-Model'!!MirrorCell methodsFor: 'accessing' stamp: 'mdm 2/19/2014 21:09'!leansLeft	^ leansLeft! !!MirrorCell methodsFor: 'accessing' stamp: 'mdm 2/19/2014 21:08'!leansLeft: anObject	 leansLeft := anObject! !!MirrorCell methodsFor: 'initialize-release' stamp: 'mdm 2/19/2014 21:36'!initialize	"initialize mirror cell"      super initialize.      self initializeExitSides.      self leanLeft.! !!MirrorCell methodsFor: 'initialize-release' stamp: 'mdm 1/30/2014 07:30'!initializeExitSides	"initializes exitSides instance variable"      self exitSides: Dictionary new.      ! !!MirrorCell methodsFor: 'testing' stamp: 'mdm 1/28/2014 07:49'!isLeft	"is mirror leaning left?"      ^self leansLeft.! !!MirrorCell methodsFor: 'testing' stamp: 'mdm 2/19/2014 21:10'!isRight	"is the mirror leaning to the right?"     ^self isLeft not.! !!MirrorCell methodsFor: 'as yet unclassified' stamp: 'mdm 1/30/2014 07:25'!leanLeft	"lean mirror to the left"      self leansLeft: true.      self exitSides at: #north put: #east.      self exitSides at: #east put: #north.      self exitSides at: #south put: #west.      self exitSides at: #west put: #south.! !!MirrorCell methodsFor: 'as yet unclassified' stamp: 'mdm 1/30/2014 07:28'!leanRight	"lean mirror to the right"      self leansLeft: false.      self exitSides at: #north put: #west.      self exitSides at: #east put: #south.      self exitSides at: #south put: #east.      self exitSides at: #west put: #north.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MirrorCell class	instanceVariableNames: ''!!MirrorCell class methodsFor: 'instance creation' stamp: 'mdm 2/19/2014 21:19'!leanLeft	"returns a new instance that leansLeft"      ^super new leanLeft! !!MirrorCell class methodsFor: 'instance creation' stamp: 'mdm 2/19/2014 21:22'!leanRight	"returns a MirrorCell instance that leansRight"      ^super new leanRight! !Cell subclass: #TargetCell	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Laser-Game-Model'!!TargetCell methodsFor: 'initialize-release' stamp: 'mdm 2/19/2014 21:42'!initialize	"initialize instance variables"      super initialize.      self initializeExitSides.! !!TargetCell methodsFor: 'initialize-release' stamp: 'mdm 2/2/2014 22:53'!initializeExitSides	"one beam enters. no beam leaves"      self exitSides: Dictionary new.      self exitSides at: #north put: nil.      self exitSides at: #east put: nil.      self exitSides at: #south put: nil.      self exitSides at: #west put: nil.! !